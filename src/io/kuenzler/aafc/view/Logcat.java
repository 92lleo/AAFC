package io.kuenzler.aafc.view;

import io.kuenzler.aafc.control.Aafc;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

import javax.swing.SwingUtilities;

import java.awt.Toolkit;

/**
 *
 * @author lleo
 */
public class Logcat extends javax.swing.JFrame {

    /**
     * Creates new form commandbuilder
     */
    final String path;
    final Aafc main;
    LogcatExecuter executer;

    public Logcat(Aafc main, String path) {
    	setIconImage(Toolkit.getDefaultToolkit().getImage(Logcat.class.getResource("/res/icon.jpeg")));
        initComponents();
        this.path = path;
        this.main = main;
        startLogcat("");
        executer = null;        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        ta_logcat = new javax.swing.JTextArea();
        ta_logcat.setLineWrap(true);
        t_filter = new javax.swing.JTextField();
        l_filter = new javax.swing.JLabel();
        b_refresh = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Logcat");

        ta_logcat.setEditable(false);
        ta_logcat.setColumns(20);
        ta_logcat.setRows(5);
        ta_logcat.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jScrollPane1.setViewportView(ta_logcat);

        l_filter.setText("Filter");

        b_refresh.setText("Refresh");
        b_refresh.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                b_refreshActionPerformed(evt);
            }
        });

        jLabel1.setText("Logcat will be displayed permanently, use refresh to restart with filter");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 493, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(l_filter)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                            .addComponent(t_filter)
                            .addGap(18, 18, 18)
                            .addComponent(b_refresh, javax.swing.GroupLayout.PREFERRED_SIZE, 96, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 412, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(6, 6, 6)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(t_filter, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(b_refresh)
                    .addComponent(l_filter))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 256, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }
    

    private void b_refreshActionPerformed(java.awt.event.ActionEvent evt) {
        updateCommandline("refresh pressed");
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                updateCommandline("refresh pressed 2");
                stopLogcat();
                startLogcat(t_filter.getText());
                updateCommandline("refresh pressed 3");
            }
        });

    }
    private javax.swing.JButton b_refresh;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel l_filter;
    private javax.swing.JTextField t_filter;
    private javax.swing.JTextArea ta_logcat;
    // End of variables declaration//GEN-END:variables

    private void startLogcat(String filter) {
        executer = new LogcatExecuter(this);
        executer.runCommand(filter);
        if (filter.equals("")) {
            updateCommandline("--Locat output startet without filter");
        } else {
            updateCommandline("--Locat output startet with filter \"" + filter + "\"");
        }
    }

    private void stopLogcat() {
        executer.getProcess().destroy();
        executer.interrupt();
        updateCommandline("--Logcat output stopped");
    }

    protected void updateCommandline(String update) {
        ta_logcat.setText(ta_logcat.getText() + update);
    }

    /**
     *
     * @author Leonhard Künzler
     * @date 22.06.12 0:20
     */
    class LogcatExecuter extends Thread {

        private ProcessBuilder builder;
        public String command; //später private
        private Process process;
        private final Logcat logcat;
        /*
         *        
         */

        protected LogcatExecuter(final Logcat logcat) {
            this.logcat = logcat;
        }

        @Override
        public void run() {
            builder = build_command(command);
            try {
                process = builder.start();
            } catch (Exception ex) {
                updateCommandline("--Crashed while starting process (" + command + ")\n--" + ex);
                return;
            }
            InputStream is = process.getInputStream();
            InputStreamReader isr = new InputStreamReader(is);
            BufferedReader br = new BufferedReader(isr);
            String line = "";
            String current;
            try {
                long lastProgressBarUpdate = System.currentTimeMillis();
                while ((current = br.readLine()) != null && !isInterrupted()) {
                    line += current + "\n";
                    long currentTime = System.currentTimeMillis();
                    if (currentTime > lastProgressBarUpdate + 250) {
                        lastProgressBarUpdate = currentTime;
                        updateCommandline(line);
                        line = "";
                    }
                }
                updateCommandline(line);
            } catch (IOException ex) {
                updateCommandline("--Crashed while reading cmd output");
            }
            //updateCommandline(line);
            try {
                process.waitFor();
            } catch (InterruptedException ex) {
                updateCommandline("--Error while waiting for " + command);
            }
        }

        /**
         *
         * @param update Text to write into commandline
         */
        private void updateCommandline(final String update) {
            SwingUtilities.invokeLater(new Runnable() {
                @Override
                public void run() {
                    logcat.updateCommandline(update);
                }
            });
        }

        /**
         * Forwards command to processbuilder, sets flags and executes.
         *
         * @param command command as string
         * @param mode mode to run: 0:nomode 1:adb 2:fastboot 3:cmd
         * @param wait true:join, false:ignore
         * @param show true:show update in gui, false:silent
         */
        public void runCommand(String filter) {
            this.command = "logcat" + filter;
            start();
        }

        public Process getProcess() {
            return process;
        }

        /**
         *
         * @param command auszuführender befehl
         * @return
         */
        ProcessBuilder build_command(String command) {
            String[] cmdarray, progcmdarray;
            ProcessBuilder pb = new ProcessBuilder();
            cmdarray = command.split(" ");
            progcmdarray = new String[cmdarray.length + 1];
            progcmdarray[0] = logcat.path + "adb.exe";
            for (int i = 1; i < progcmdarray.length; i++) {
                progcmdarray[i] = cmdarray[i - 1];
            }
            pb = pb.command(progcmdarray);

            return pb.redirectErrorStream(true);
        }
    }
}
